# -*- coding: utf-8 -*-
"""local_search_py_new5.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1dVyBsV_qK6_Nn_ohge3UI63IgV73L6gn
"""

from __future__ import annotations

"""
Local search methods for post-processing optimization results.
"""
import logging
from itertools import combinations
from typing import Callable

import numpy as np
from numba import jit

LOGGER = logging.getLogger(__name__)

@jit
def _core(x, val, refval, maxfevals, all_combinations, maxiter, func, maxepoch):
    """
    Core local search engine using the "Best Improvement" (or Steepest Descent) strategy.
    This function is accelerated with Numba's JIT compiler.
    """
    fevals = 0
    epoch = 0
    is_local_minimum = True

    while True: 

      
        if np.isclose(val, refval) or val < refval:
            break
        if maxfevals != -1 and fevals >= maxfevals:
            break
        if maxepoch != -1 and epoch >= maxepoch:
            break

      
        best_x_in_epoch = x
        best_val_in_epoch = val
        is_local_minimum = True

        combs = np.random.permutation(all_combinations)
        if maxiter is not None:
            combs = combs[:maxiter]

       
        for comb in combs:
            z = np.copy(x)
            for idx in comb:
                z[idx] = 1 - z[idx]

            val_flip = func(z)
            fevals += 1

            # If this neighbor is the best one found *so far in this epoch*, save it.
            if val_flip < best_val_in_epoch:
                best_val_in_epoch = val_flip
                best_x_in_epoch = np.copy(z)

            if maxfevals != -1 and fevals >= maxfevals:
                break

        
        if best_val_in_epoch < val:
          
            x = best_x_in_epoch
            val = best_val_in_epoch
            is_local_minimum = False

        
        if is_local_minimum:
            break

        epoch += 1

    return x, val, epoch, fevals, is_local_minimum

def _local_search_general(x, val, func: Callable, options):
    """
    Reference paper: https://arxiv.org/pdf/2406.01743 (q-ctrl)
    """
    k = options.get("local_search_num_bitflips", 1)
    maxiter = options.get("local_search_maxiter", None)
    maxepoch = options.get("local_search_maxepoch", 5)
    refval = options.get("refval", None)
    maxfevals = options.get("local_search_maxfevals", None)

    if maxfevals is None:
        maxfevals = -1
    if maxepoch is None:
        maxepoch = -1

    n = len(x)
    all_combinations = np.array(list(combinations(range(n), k)))
    return _core(x.astype(float), val, refval, maxfevals, all_combinations, maxiter, func, maxepoch)

def repeated_local_search_general(x, val, func: Callable, options):
    """
    Repeats the local search `maxreps` times
    """
    maxreps = options.get("local_search_repeated_maxreps", 1)
    refval = options.get("refval", None)
    x_best = x
    val_best = val

    num_epochs = []
    num_fevals = []
    vals = []

    for _ in range(maxreps):
        x_new, val_new, epochs, fevals, is_local_minimum = _local_search_general(
            x, val, func, options
        )

        if refval is not None and (np.isclose(val_best, np.float64(refval)) or val_best < refval):
            break

        num_epochs.append(epochs)
        num_fevals.append(fevals)
        vals.append(val_new)

        if val_new < val_best:
            x_best = x_new
            val_best = val_new

        if epochs == 0 and is_local_minimum:
            break

    return x_best, val_best, num_epochs, num_fevals, vals

def variable_neighborhood_search(x, val, func: Callable, options):
    """
    Performs a Variable Neighborhood Search to escape local minima.
    """
    k_local_search = options.get("local_search_num_bitflips", 1)
    k_max = options.get("local_search_vns_k_max", 3)
    inner_options = options.copy()
    inner_options["local_search_num_bitflips"] = k_local_search
    n = len(x)
    x_best, val_best, _, _, _ = _local_search_general(x, val, func, inner_options)

    k = 2
    while k <= k_max:
        shake_combinations = np.array(list(combinations(range(n), k)))
        random_shake_indices = shake_combinations[np.random.choice(len(shake_combinations))]

        x_shaken = np.copy(x_best)
        for idx in random_shake_indices:
            x_shaken[idx] = 1 - x_shaken[idx]
        val_shaken = func(x_shaken)

        x_new, val_new, _, _, _ = _local_search_general(x_shaken, val_shaken, func, inner_options)

        if val_new < val_best:
            x_best = x_new
            val_best = val_new
            k = 2
        else:
            k += 1

    return x_best, val_best, [], [], []